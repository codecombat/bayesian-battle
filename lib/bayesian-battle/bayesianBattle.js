// Generated by CoffeeScript 1.6.3
var BayesianBattle, _;

_ = require('lodash');

BayesianBattle = (function() {
  function BayesianBattle(scoreUncertainty, k, scoreStandardDeviationCoefficient) {
    if (scoreUncertainty == null) {
      scoreUncertainty = 25 / 6;
    }
    if (k == null) {
      k = 0.0001;
    }
    if (scoreStandardDeviationCoefficient == null) {
      scoreStandardDeviationCoefficient = 1.8;
    }
    if (this.scoreUncertainty == null) {
      this.scoreUncertainty = scoreUncertainty;
    }
    if (this.k == null) {
      this.k = k;
    }
    if (this.scoreStandardDeviationCoefficient == null) {
      this.scoreStandardDeviationCoefficient = scoreStandardDeviationCoefficient;
    }
  }

  /*sample playerAndScoreObject would be
  {
    playerID: 1,
    meanStrength: 50,
    standardDeviation: 24.3
    gameRanking: 2 #rank in game
  */


  BayesianBattle.prototype.updatePlayerSkills = function(playerAndScoreObjectsArray) {
    var chanceOfPlayerOneBeatingPlayerTwo, chanceOfPlayerTwoBeatingPlayerOne, meanStrengthChangePartial, meanStrengthChangePartialSum, meanStrengthChangePartials, pairwiseGameOutcomeValue, pairwisePerformanceUncertainty, player, playerOne, playerTwo, returnArray, squaredDeviationChangePartial, squaredStandardDeviationChangePartialSum, squaredStandardDeviationChangePartials, _i, _j, _len, _len1, _ref;
    this.validateInputArray(playerAndScoreObjectsArray);
    returnArray = _.cloneDeep(playerAndScoreObjectsArray);
    for (_i = 0, _len = returnArray.length; _i < _len; _i++) {
      playerOne = returnArray[_i];
      meanStrengthChangePartials = [];
      squaredStandardDeviationChangePartials = [];
      _ref = (function() {
        var _k, _len1, _results;
        _results = [];
        for (_k = 0, _len1 = returnArray.length; _k < _len1; _k++) {
          player = returnArray[_k];
          if (player !== playerOne) {
            _results.push(player);
          }
        }
        return _results;
      })();
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        playerTwo = _ref[_j];
        pairwisePerformanceUncertainty = this.calculateTotalPerformanceUncertainty(playerOne.standardDeviation, playerTwo.standardDeviation);
        chanceOfPlayerOneBeatingPlayerTwo = this.calculateChanceOfPlayerOneBeatingPlayerTwo(playerOne.meanStrength, playerTwo.meanStrength, pairwisePerformanceUncertainty);
        chanceOfPlayerTwoBeatingPlayerOne = this.calculateChanceOfPlayerTwoBeatingPlayerOne(playerTwo.meanStrength, playerOne.meanStrength, pairwisePerformanceUncertainty);
        pairwiseGameOutcomeValue = this.calculatePairwiseGameOutcomeValue(playerOne.gameRanking, playerTwo.gameRanking);
        meanStrengthChangePartial = this.calculateMeanStrengthChangePartial(playerOne.standardDeviation, pairwisePerformanceUncertainty, pairwiseGameOutcomeValue, chanceOfPlayerOneBeatingPlayerTwo);
        squaredDeviationChangePartial = this.calculateSquaredStandardDeviationChangePartial(playerOne.standardDeviation, pairwisePerformanceUncertainty, chanceOfPlayerOneBeatingPlayerTwo, chanceOfPlayerTwoBeatingPlayerOne);
        meanStrengthChangePartials.push(meanStrengthChangePartial);
        squaredStandardDeviationChangePartials.push(squaredDeviationChangePartial);
      }
      meanStrengthChangePartialSum = this.sumArray(meanStrengthChangePartials);
      squaredStandardDeviationChangePartialSum = this.sumArray(squaredStandardDeviationChangePartials);
      this.updateSkills(playerOne, meanStrengthChangePartialSum, squaredStandardDeviationChangePartialSum);
    }
    return returnArray;
  };

  BayesianBattle.prototype.calculatePlayerScoreFromPlayerMetrics = function(playerMeanStrength, playerStandardDeviation) {
    return playerMeanStrength - this.scoreStandardDeviationCoefficient * playerStandardDeviation;
  };

  BayesianBattle.prototype.validateInputArray = function(playerAndScoreObjectsArray) {
    var playerAndScoreObject, _i, _len;
    this.validatePlayerArrayLength(playerAndScoreObjectsArray);
    for (_i = 0, _len = playerAndScoreObjectsArray.length; _i < _len; _i++) {
      playerAndScoreObject = playerAndScoreObjectsArray[_i];
      this.validateRequiredProperties(playerAndScoreObject);
      this.validatePlayerObjectValues(playerAndScoreObject, playerAndScoreObjectsArray.length);
    }
    return this.validateUniquePlayerIDs(playerAndScoreObjectsArray);
  };

  BayesianBattle.prototype.validateRequiredProperties = function(playerAndScoreObject) {
    if (!_.has(playerAndScoreObject, 'id')) {
      throw new Error("Player object is missing ID.");
    }
    if (!_.has(playerAndScoreObject, 'meanStrength')) {
      throw new Error("Player object is missing mean strength");
    }
    if (!_.has(playerAndScoreObject, 'standardDeviation')) {
      throw new Error("Player object is missing standard deviation");
    }
    if (!_.has(playerAndScoreObject, 'gameRanking')) {
      throw new Error("Player object is missing game ranking");
    }
  };

  BayesianBattle.prototype.validateUniquePlayerIDs = function(playerAndScoreObjectsArray) {
    var ids, uniqueIDs;
    ids = _.pluck(playerAndScoreObjectsArray, 'id');
    uniqueIDs = _.uniq(ids);
    if (uniqueIDs.length !== ids.length) {
      throw new Error("All IDs must be unique");
    }
  };

  BayesianBattle.prototype.validatePlayerArrayLength = function(playerAndScoreObjectsArray) {
    if (playerAndScoreObjectsArray.length <= 1) {
      throw new Error("Input array must contain two objects or more");
    }
  };

  BayesianBattle.prototype.validatePlayerObjectValues = function(playerAndScoreObject, arrayLength) {
    if (playerAndScoreObject.meanStrength <= 0) {
      throw new Error("Mean strength must be greater than 0.");
    }
    if (playerAndScoreObject.standardDeviation <= 0) {
      throw new Error("Standard Deviation must be greater than 0");
    }
    if (playerAndScoreObject.gameRanking < 0) {
      throw new Error("Game ranking must be greater than or equal to 0");
    }
    if (playerAndScoreObject.gameRanking >= arrayLength) {
      throw new Error("Game ranking must be less than number of players");
    }
  };

  BayesianBattle.prototype.calculateTotalPerformanceUncertainty = function(playerOneStandardDeviation, playerTwoStandardDeviation) {
    var playerOneStandardDeviationSquared, playerTwoStandardDeviationSquared, scoreUncertaintySquared, totalPairwiseUncertaintySquared;
    playerOneStandardDeviationSquared = Math.pow(playerOneStandardDeviation, 2);
    playerTwoStandardDeviationSquared = Math.pow(playerTwoStandardDeviation, 2);
    scoreUncertaintySquared = Math.pow(this.scoreUncertainty, 2);
    totalPairwiseUncertaintySquared = playerOneStandardDeviationSquared + playerTwoStandardDeviationSquared + 2 * scoreUncertaintySquared;
    return Math.sqrt(totalPairwiseUncertaintySquared);
  };

  BayesianBattle.prototype.calculateChanceOfPlayerOneBeatingPlayerTwo = function(playerOneMeanStrength, playerTwoMeanStrength, performanceUncertainty) {
    return this.calculateMatchSuccessProbability(playerOneMeanStrength, playerTwoMeanStrength, performanceUncertainty);
  };

  BayesianBattle.prototype.calculateChanceOfPlayerTwoBeatingPlayerOne = function(playerTwoMeanStrength, playerOneMeanStrength, performanceUncertainty) {
    return this.calculateMatchSuccessProbability(playerTwoMeanStrength, playerOneMeanStrength, performanceUncertainty);
  };

  BayesianBattle.prototype.calculateMatchSuccessProbability = function(playerOneMeanStrength, playerTwoMeanStrength, performanceUncertainty) {
    var playerOneCoefficient, playerTwoCoefficient;
    playerOneCoefficient = Math.exp(playerOneMeanStrength / performanceUncertainty);
    playerTwoCoefficient = Math.exp(playerTwoMeanStrength / performanceUncertainty);
    return playerOneCoefficient / (playerOneCoefficient + playerTwoCoefficient);
  };

  BayesianBattle.prototype.calculateMeanStrengthChangePartial = function(playerOneStandardDeviation, performanceUncertainty, gameOutcomeValue, probabilityOfOneBeatingTwo) {
    var adjustedOutcomeCoefficient, uncertaintyCoefficient;
    uncertaintyCoefficient = Math.pow(playerOneStandardDeviation, 2) / performanceUncertainty;
    adjustedOutcomeCoefficient = gameOutcomeValue - probabilityOfOneBeatingTwo;
    return uncertaintyCoefficient * adjustedOutcomeCoefficient;
  };

  BayesianBattle.prototype.calculateSquaredStandardDeviationChangePartial = function(playerOneStandardDeviation, performanceUncertainty, probabilityOfOneBeatingTwo, probabilityOfTwoBeatingOne) {
    var probabilityProduct, uncertaintyCoefficient;
    uncertaintyCoefficient = playerOneStandardDeviation / performanceUncertainty;
    probabilityProduct = probabilityOfOneBeatingTwo * probabilityOfTwoBeatingOne;
    return uncertaintyCoefficient * Math.pow(uncertaintyCoefficient, 2) * probabilityProduct;
  };

  BayesianBattle.prototype.calculatePairwiseGameOutcomeValue = function(playerOneGameRanking, playerTwoGameRanking) {
    if (playerOneGameRanking < playerTwoGameRanking) {
      return 1;
    }
    if (playerOneGameRanking === playerTwoGameRanking) {
      return 0.5;
    }
    if (playerOneGameRanking > playerTwoGameRanking) {
      return 0;
    }
  };

  BayesianBattle.prototype.sumArray = function(inputArray) {
    return inputArray.reduce(function(elementOne, elementTwo) {
      return elementOne + elementTwo;
    });
  };

  BayesianBattle.prototype.updateSkills = function(player, meanStrengthChangePartialSum, squaredStandardDeviationPartialSum) {
    var playerSquaredStandardDeviation, updatedPlayerSquaredStandardDeviation;
    player.meanStrength = player.meanStrength + meanStrengthChangePartialSum;
    playerSquaredStandardDeviation = Math.pow(player.standardDeviation, 2);
    updatedPlayerSquaredStandardDeviation = playerSquaredStandardDeviation * Math.max(1 - squaredStandardDeviationPartialSum, this.k);
    player.standardDeviation = Math.sqrt(updatedPlayerSquaredStandardDeviation);
  };

  return BayesianBattle;

})();

module.exports = BayesianBattle;
